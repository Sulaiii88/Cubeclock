<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CubeClock</title>

  <!-- Sorgt dafür, dass die Seite auf mobilen Geräten korrekt skaliert -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Monospace-Schriftart für die Ziffern -->
  <link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet" />

  <!-- PWA: Manifest & Farben/Statusbar-Einstellungen -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#000000" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <script>
    // Registriert den Service Worker (für PWA/Offline). Nur wenn vom Browser unterstützt.
    if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');
  </script>

  <style>
    /* =========================
       Basislayout & 3D-Würfel
       ========================= */

    /* Vollbild-Canvas, schwarze Fläche, kein Scrollen; Touch kann der Würfel abfangen */
    body{
      margin:0;
      background:#000;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      height:100vh;
      font-family:'Space Mono',monospace;
      overflow:hidden;
      touch-action:none;
    }

    /* "Bühne" für den 3D-Würfel mit Perspektive */
    .scene{
      width:63vmin;
      height:63vmin;
      perspective:1100px;
      margin-bottom:90px; /* Platz für den Button unten */
    }

    /* Der eigentliche Würfel-Container (dreht sich) */
    .cube{
      width:100%;
      height:100%;
      position:relative;
      transform-style:preserve-3d; /* Kinder bleiben 3D */
      transition:transform 1s ease; /* sanfte Drehung */
      transform:rotateX(-30deg) rotateY(45deg); /* Startposition */
    }

    /* Jede Seite (Face) des Würfels */
    .face{
      position:absolute;
      width:100%;
      height:100%;
      background:linear-gradient(to bottom right,#000,#111); /* leichtes Shading */
      color:#fff;
      font-size:calc(63vmin / 1.5);
      letter-spacing:-5px;
      display:flex;
      justify-content:center;
      align-items:center;
      border:1px solid #555;
      backface-visibility:hidden; /* Rückseite einer Face nicht zeigen */
    }

    /* Kein Text-Selection-Highlighting beim Ziehen */
    .scene,.cube,.face{user-select:none;outline:none;}

    /* Farben der Anzeigen (Ziffern) pro Face */
    #hours{color:#e71f1b;}
    #minutes{color:#ff8c42;}
    #seconds{color:#fff275;}
    #year{color:#4B0082;}
    #day{color:#87c8fa;}

    /* Monatsseite hat größere Schrift (Kurzform „Jan, Feb…“) */
    #month{
      color:#2f4fba;
      font-size:calc(63vmin / 2);
      font-weight:bold;
    }

    /* Positionierung der sechs Flächen im Raum (jeweils halbe Kantenlänge nach außen) */
    .front{ transform:rotateY( 90deg) translateZ(31.5vmin) rotateY(180deg) rotateX(180deg); }
    .back { transform:rotateY(180deg) translateZ(31.5vmin) rotateY(180deg) rotateX(180deg); }
    .right{ transform:rotateY(  0deg) translateZ(31.5vmin); }
    .left { transform:rotateY(-90deg) translateZ(31.5vmin); }
    .top  { transform:rotateX( 90deg) translateZ(31.5vmin); }
    .bottom{ transform:rotateX(-90deg) translateZ(31.5vmin); }

    /* Unten mittig: Toggle-Button (Spacebar-Icon) */
    #toggleButton{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      bottom:5vh;
      padding:1px 100px;
      border:none;
      outline:none;
      box-shadow:none;
      border-radius:10px;
      background:#444;
      cursor:pointer;
      z-index:10;
    }
    #toggleButton:hover{background:#666;}
    #toggleButton img{width:30px;height:auto;display:block;}

    /* Desktop: Würfel etwas kleiner skalieren */
    @media (min-width:601px){
      .scene{width:50vmin;height:50vmin;}
      .face{font-size:calc(50vmin / 1.5);}
      #month{font-size:calc(50vmin / 2);}
      .front{ transform:rotateY( 90deg) translateZ(25vmin) rotateY(180deg) rotateX(180deg); }
      .back { transform:rotateY(180deg) translateZ(25vmin) rotateY(180deg) rotateX(180deg); }
      .right{ transform:rotateY(  0deg) translateZ(25vmin); }
      .left { transform:rotateY(-90deg) translateZ(25vmin); }
      .top  { transform:rotateX( 90deg) translateZ(25vmin); }
      .bottom{ transform:rotateX(-90deg) translateZ(25vmin); }
    }

    /* Installierte PWA auf kleinen Displays: Würfel größer wirken lassen */
    @media (display-mode:standalone) and (max-width:600px){
      .scene{transform:scale(3);transform-origin:center;}
    }

    /* =========================
       Settings (Zahnrad & Panel)
       ========================= */

    /* Abdunkelung hinter dem Panel */
    #settingsOverlay{
      position:fixed;inset:0;
      background:rgba(0,0,0,.45);
      display:none;z-index:150;
    }

    /* Zahnrad-Button oben links mit sichtbarem Rahmen */
    #settingsButton{
      position:fixed;
      top:calc(env(safe-area-inset-top,0px) + 12px);
      left:calc(env(safe-area-inset-left,0px) + 12px);
      width:44px;height:44px;
      padding:8px;background:#222;
      border:1.5px solid rgba(255,255,255,.35); /* Rahmen, damit auf hell/dunkel sichtbar */
      border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.35);
      cursor:pointer;z-index:200;
      display:flex;align-items:center;justify-content:center;
    }
    #settingsButton img{width:28px;height:28px;display:block;filter:drop-shadow(0 0 2px rgba(0,0,0,.3));}

    /* Panel selbst; kompakt und scrollbar, damit „Close“ nie abgeschnitten wird */
    #settingsPanel{
      position:fixed;
      top:calc(env(safe-area-inset-top,0px) + 62px);
      left:calc(env(safe-area-inset-left,0px) + 12px);
      display:none;z-index:180;
      width:clamp(240px,86vw,340px);
      max-height:calc(100dvh - 96px);
      overflow:auto;overscroll-behavior:contain;
      background:#222;border:1px solid rgba(255,255,255,.10);
      border-radius:18px;color:#fff;
      box-shadow:0 18px 40px rgba(0,0,0,.5);
      padding:14px 12px 18px;  /* extra Platz unten für Buttons */
    }

    /* Kleiner Pfeil unter dem Zahnrad (Dekor) */
    #panelArrow{
      position:fixed;display:none;z-index:181;
      top:calc(env(safe-area-inset-top,0px) + 54px);
      left:calc(env(safe-area-inset-left,0px) + 36px);
      width:0;height:0;
      border-left:10px solid transparent;
      border-right:10px solid transparent;
      border-bottom:12px solid #222;
    }

    #settingsPanel h3{margin:0 0 10px;font-size:20px;letter-spacing:.5px;}

    /* Eine Zeile im Panel: Label links, Farbfeld (chip) rechts */
    .row{
      display:flex;align-items:center;justify-content:space-between;
      gap:10px;font-size:18px;color:#eaeaea;margin:8px 0;
    }

    /* Kleines Farbfeld mit weißem Rahmen, zeigt aktuelle Farbe */
    .chip{
      width:50px;height:28px;border:4px solid #fff;border-radius:8px;
      box-shadow:inset 0 0 0 1px rgba(0,0,0,.35),0 2px 8px rgba(0,0,0,.25);
      cursor:pointer;position:relative;background:#000;
    }
    .chip::after{content:"";position:absolute;inset:4px;border-radius:6px;background:var(--chip,#000);}

    /* Standard-Buttons im Panel */
    .btn{
      display:block;width:100%;margin-top:10px;padding:9px 10px;border-radius:14px;
      border:1px solid rgba(255,255,255,.1);
      background:#2b2b2b;color:#e8e8e8;font-size:14px;text-align:center;
      box-shadow:inset 0 -2px 0 rgba(255,255,255,.05), 0 2px 10px rgba(0,0,0,.25);
    }
    .btn:hover{background:#3a3a3a;}

    /* Kompaktere Darstellung bei sehr niedriger Bildschirmhöhe */
    @media (max-height:700px){
      #settingsPanel{width:clamp(230px,90vw,320px);padding:12px 10px 16px;max-height:calc(100dvh - 88px);}
      #settingsPanel h3{font-size:17px}
      .row{font-size:14px;margin:7px 0}
      .chip{width:46px;height:26px}
      .btn{font-size:13px;padding:8px 9px}
    }
    @media (max-height:580px){
      #settingsPanel{max-height:calc(100dvh - 80px)}
      .row{font-size:13px}
    }

    /* Block für „Auto reset“ (Optik) */
    .reset-block{
      margin-top:10px;padding:9px;border-radius:14px;
      background:#1f1f1f;border:1px solid rgba(255,255,255,.06)
    }
    .reset-row{display:flex;align-items:center;gap:10px;margin-top:6px}
    .reset-row label{font-size:13px;opacity:.9}
    .reset-row input[type="checkbox"]{transform:scale(1.05)}
    .reset-row input[type="number"]{
      width:100px;background:#1e1e1e;border:1px solid rgba(255,255,255,.14);color:#fff;border-radius:10px;
      padding:6px 8px;font-size:13px;
    }

    /* =========================
       Eigenes RGB-Farb-Modal
       ========================= */

    #pickerOverlay{position:fixed;inset:0;background:rgba(0,0,0,.55);display:none;z-index:300;}

    /* Dialog: Farbfläche (S/V), Hue-Slider, RGB-Felder, Vorschau */
    #picker{
      position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);
      width:min(92vw,380px);
      background:#2a2a2a;border:1px solid rgba(255,255,255,.12);
      border-radius:16px;box-shadow:0 20px 50px rgba(0,0,0,.6);
      padding:14px;display:none;z-index:301;color:#fff;
    }
    #picker h4{margin:0 0 10px;font-size:16px}

    .sv-wrap{position:relative;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,.15);}
    #sv{width:100%;height:180px;display:block;background:#f00;cursor:crosshair}
    .sv-cursor{position:absolute;width:16px;height:16px;border:2px solid #fff;border-radius:50%;box-shadow:0 0 0 2px rgba(0,0,0,.3);pointer-events:none}

    .h-wrap{position:relative;margin:10px 0}
    #h{
      width:100%;height:14px;border-radius:10px;appearance:none;
      background:linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);
      outline:none;border:1px solid rgba(255,255,255,.15)
    }
    #h::-webkit-slider-thumb{appearance:none;width:18px;height:18px;border-radius:50%;background:#fff;border:1px solid #000}

    .rgb-row{display:flex;gap:8px;margin-top:10px}
    .rgb-row .cell{flex:1}
    .rgb-row label{display:block;font-size:12px;opacity:.85;margin-bottom:4px}
    .rgb-row input{
      width:100%;max-width:90px;background:#1e1e1e;border:1px solid rgba(255,255,255,.14);color:#fff;border-radius:10px;
      padding:4px 6px;font-size:12px;line-height:1.2; /* kleine, aber fingerfreundliche Inputs */
    }

    #preview{height:36px;border-radius:10px;border:1px solid rgba(255,255,255,.18);margin:10px 0;background:#000}

    .picker-actions{display:flex;gap:10px;margin-top:8px}
    .picker-actions button{flex:1;border:none;border-radius:12px;padding:10px 12px;background:#3a3a3a;color:#fff;box-shadow:0 2px 10px rgba(0,0,0,.25)}
    .picker-actions button.primary{background:#4b7bec}
  </style>
</head>
<body>
  <!-- Bühne + Würfel mit 6 Seiten (Zeit/Datum) -->
  <div class="scene">
    <div class="cube" id="cube">
      <div class="face front"  id="year">00</div>
      <div class="face back"   id="month">00</div>
      <div class="face right"  id="seconds">00</div>
      <div class="face left"   id="minutes">00</div>
      <div class="face top"    id="hours">00</div>
      <div class="face bottom" id="day">00</div>
    </div>
  </div>

  <!-- Spacebar-Button zum Umschalten zwischen Uhr/Datum -->
  <button id="toggleButton" onclick="toggleCube()">
    <img src="spacebar_icon.png" alt="spacebar" />
  </button>

  <!-- Zahnrad-Button & Settings-Layer -->
  <button id="settingsButton" type="button" aria-label="Settings">
    <img src="settings.png" alt="Settings" />
  </button>
  <div id="panelArrow"></div>
  <div id="settingsOverlay"></div>

  <!-- Einstellungs-Panel: Farben + Auto-Reset + Aktionen -->
  <div id="settingsPanel" role="dialog" aria-label="Settings">
    <h3>Change colors</h3>
    <div class="row">Hour:       <div class="chip" id="chipHours"   data-key="hours"></div></div>
    <div class="row">Minute:     <div class="chip" id="chipMinutes" data-key="minutes"></div></div>
    <div class="row">Second:     <div class="chip" id="chipSeconds" data-key="seconds"></div></div>
    <div class="row">Year:       <div class="chip" id="chipYear"    data-key="year"></div></div>
    <div class="row">Month:      <div class="chip" id="chipMonth"   data-key="month"></div></div>
    <div class="row">Day:        <div class="chip" id="chipDay"     data-key="day"></div></div>
    <div class="row">Cube: <div class="chip" id="chipCube"    data-key="cube"></div></div>
    <div class="row">Background: <div class="chip" id="chipBackground" data-key="background"></div></div>

    <!-- Auto-Reset: Würfel nach Inaktivität zurückdrehen -->
    <div class="reset-block">
      <strong>Auto reset</strong>
      <div class="reset-row">
        <input type="checkbox" id="autoResetEnable">
        <label for="autoResetEnable">Enable</label>
      </div>
      <div class="reset-row">
        <label for="autoResetSeconds">Seconds</label>
        <input type="number" id="autoResetSeconds" min="1" max="3600" step="1" placeholder="10">
      </div>
    </div>

    <!-- Panel-Aktionen -->
    <button class="btn" type="button" id="btnDefaults">Reset to defaults</button>
    <button class="btn" type="button" onclick="toggleCube()">Time/Date (space)</button>
    <button class="btn" type="button" id="closeSettingsBtn">Close</button>
  </div>

  <!-- Eigenes Farb-Dialogfenster (RGB + SV/H) -->
  <div id="pickerOverlay"></div>
  <div id="picker">
    <h4>Select color</h4>
    <div class="sv-wrap">
      <canvas id="sv"></canvas>
      <div class="sv-cursor" id="svc"></div>
    </div>
    <div class="h-wrap">
      <input id="h" type="range" min="0" max="360" value="0">
    </div>
    <div id="preview"></div>
    <div class="rgb-row">
      <div class="cell"><label for="r">R</label><input id="r" type="number" min="0" max="255"></div>
      <div class="cell"><label for="g">G</label><input id="g" type="number" min="0" max="255"></div>
      <div class="cell"><label for="b">B</label><input id="b" type="number" min="0" max="255"></div>
    </div>
    <div class="picker-actions">
      <button id="cancelPick">Cancel</button>
      <button id="applyPick" class="primary">Apply</button>
    </div>
  </div>

  <script>
    /* =========================
       Zeit-Update & Interaktion
       ========================= */

    // Zustände für Drehung/Interaktion
    let showingDate=false, rotateX=-30, rotateY=45, isDragging=false, lastX,lastY, userRotated=false, inactivityTimer, toggleCount=0;

    // Referenzen
    const cube=document.getElementById("cube");
    const toggleButton=document.getElementById("toggleButton");

    // Schreibt die aktuelle Uhrzeit/Datum in die sechs Flächen
    function updateTime(){
      const now=new Date();
      const monthNames=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
      hours.textContent  = String(now.getHours()).padStart(2,'0');
      minutes.textContent= String(now.getMinutes()).padStart(2,'0');
      seconds.textContent= String(now.getSeconds()).padStart(2,'0');
      year.textContent   = String(now.getFullYear()%100).padStart(2,'0');
      month.textContent  = monthNames[now.getMonth()];
      day.textContent    = String(now.getDate()).padStart(2,'0');
    }

    // Umschalten zwischen Uhr-Ansicht und Datum (auch via Spacebar)
    function toggleCube(){
      toggleCount++;
      if(toggleCount>=2)toggleButton.style.display="none"; // Button nach 2x ausblenden (wie von dir gewollt)
      showingDate=!showingDate;
      rotateX=showingDate?-215:-30; // andere Seite zeigen
      rotateY=45;
      cube.style.transform=`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
    }

    // Nach Inaktivität/Manueller Drehung zur Ursprungsansicht zurück
    function resetToClockView(){
      if(showingDate||userRotated){
        showingDate=false; userRotated=false; rotateX=-30; rotateY=45;
        cube.style.transform=`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      }
    }

    // Timer starten/erneuern (abhängig von Auto‑Reset-Settings)
    function startInactivityTimer(){
      clearTimeout(inactivityTimer);
      if(!autoResetEnabled) return;
      inactivityTimer=setTimeout(resetToClockView, autoResetSeconds*1000);
    }

    // Maussteuerung: Drag = Würfel drehen
    cube.addEventListener("mousedown",e=>{isDragging=true;lastX=e.clientX;lastY=e.clientY;});
    document.addEventListener("mouseup",()=>{isDragging=false;});
    document.addEventListener("mousemove",e=>{
      if(!isDragging)return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      rotateY+=dx*0.5; rotateX-=dy*0.5;
      cube.style.transform=`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      userRotated=true; startInactivityTimer();
    });

    // Touchsteuerung: 1‑Finger‑Drehung
    document.body.addEventListener("touchstart",e=>{const t=e.touches[0];lastX=t.clientX;lastY=t.clientY;});
    document.body.addEventListener("touchmove",e=>{
      e.preventDefault();
      const t=e.touches[0];
      const dx=t.clientX-lastX, dy=t.clientY-lastY;
      lastX=t.clientX; lastY=t.clientY;
      rotateY+=dx*1; rotateX-=dy*1;
      cube.style.transform=`rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      userRotated=true; startInactivityTimer();
    },{passive:false});

    // Spacebar: auch toggeln (aber nicht, wenn Fokus auf Input/Button)
    window.addEventListener('keydown',e=>{
      if(e.code==='Space'&&!e.target.matches('button, input, textarea')){
        e.preventDefault(); toggleCube();
      }
    });

    // Jede Sekunde Zahlen aktualisieren
    setInterval(updateTime,1000);
    updateTime();

    /* =========================
       Settings (öffnen/schließen)
       ========================= */

    const settingsBtn=document.getElementById('settingsButton');
    const settingsPanel=document.getElementById('settingsPanel');
    const settingsOverlay=document.getElementById('settingsOverlay');
    const panelArrow=document.getElementById('panelArrow');
    const closeSettingsBtn=document.getElementById('closeSettingsBtn');
    const btnDefaults=document.getElementById('btnDefaults');

    // Panel zeigen/verstecken
    function openSettings(){settingsOverlay.style.display='block';settingsPanel.style.display='block';panelArrow.style.display='block';}
    function closeSettings(){settingsOverlay.style.display='none';settingsPanel.style.display='none';panelArrow.style.display='none';}
    settingsBtn.addEventListener('click',()=> (settingsPanel.style.display==='block'?closeSettings():openSettings()));
    settingsOverlay.addEventListener('click',closeSettings);
    closeSettingsBtn.addEventListener('click',closeSettings);

    /* =========================
       Farben verwalten (Chips)
       ========================= */

    // Zuordnung: Schlüssel -> Chip-Element-ID
    const mapping={
      hours:"chipHours", minutes:"chipMinutes", seconds:"chipSeconds",
      year:"chipYear", month:"chipMonth", day:"chipDay",
      cube:"chipCube", background:"chipBackground"
    };

    // Standardfarben für die erste Benutzung
    const defaults={
      hours:"#e71f1b", minutes:"#ff8c42", seconds:"#fff275",
      year:"#4B0082", month:"#2f4fba", day:"#87c8fa",
      cube:"#111111", background:"#000000"
    };

    // Aktualisiert die visuelle Chip-Farbe
    function setChipColor(key,val){
      document.getElementById(mapping[key]).style.setProperty('--chip',val);
    }

    // Wendet eine Farbe an (entweder Textfarbe, Würfelhintergrund oder Seitenhintergrund)
    function applyColor(key,val){
      if(key==='cube'){
        document.querySelectorAll('.face').forEach(f=>f.style.background=val);
      }else if(key==='background'){
        document.body.style.background=val;
        // Bonus: Zahnrad-Button übernimmt den Hintergrund, Rahmen bleibt sichtbar
        settingsBtn.style.background = val;
        settingsBtn.style.borderColor = 'rgba(255,255,255,.35)';
      }else{
        document.getElementById(key).style.color=val;
      }
      localStorage.setItem('color-'+key,val);
      setChipColor(key,val);

      else if(key==='background'){
  document.body.style.background = val;

  // Hintergrundfarbe prüfen → Helligkeit berechnen
  const r = parseInt(val.substr(1,2),16);
  const g = parseInt(val.substr(3,2),16);
  const b = parseInt(val.substr(5,2),16);

  const brightness = 0.299*r + 0.587*g + 0.114*b;

  // Wenn Hintergrund sehr dunkel ist → Zahnrad nicht verschwinden lassen
  if (brightness < 40) {
    settingsBtn.style.background = "#222";  // fix grau
  } else {
    settingsBtn.style.background = val;     // gleiche Farbe wie Hintergrund
  }

  settingsBtn.style.borderColor = 'rgba(255,255,255,.35)';
      }
    }
 
    // Lädt gespeicherte Farben oder nimmt Defaults
    function applySavedColors(){
      Object.keys(mapping).forEach(k=>applyColor(k, localStorage.getItem('color-'+k)||defaults[k]));
    }

    // „Reset to defaults“: löscht gespeicherte Werte und wendet Defaults an
    function resetToDefaultColors(){
      Object.keys(mapping).forEach(k=>localStorage.removeItem('color-'+k));
      applySavedColors();
    }
    btnDefaults.addEventListener('click',resetToDefaultColors);

    /* =========================
       Eigenes RGB-Farbfeld (Modal)
       ========================= */

    const pickerOverlay=document.getElementById('pickerOverlay');
    const picker=document.getElementById('picker');
    const sv=document.getElementById('sv');    // S/V-Fläche (Sättigung/Helligkeit)
    const svc=document.getElementById('svc');  // Cursor auf der S/V-Fläche
    const h=document.getElementById('h');      // Hue-Slider
    const preview=document.getElementById('preview');
    const Rin=document.getElementById('r'), Gin=document.getElementById('g'), Bin=document.getElementById('b');
    let currentKey=null, hue=0, sat=1, val=1; // HSV-Zustand

    // Anzeigename pro Schlüssel (für den Dialogtitel)
    const labels={hours:"Hour",minutes:"Minute",seconds:"Second",year:"Year",month:"Month",day:"Day",cube:"Cube faces",background:"Background"};

    /* Hilfsfunktionen: Umrechnungen RGB <-> HSV + RGB -> HEX */
    function hsv2rgb(h,s,v){let f=(n,k=(n+h/60)%6)=>v-v*s*Math.max(Math.min(k,4-k,1),0);return [f(5),f(3),f(1)].map(x=>Math.round(x*255));}
    function rgb2hsv(r,g,b){r/=255;g/=255;b/=255;const max=Math.max(r,g,b),min=Math.min(r,g,b);let h,s,v=max;const d=max-min;s=max===0?0:d/max;
      if(max===min){h=0}else{switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break}h*=60}
      return [h,s,v]}
    const toHex=n=>('#'+[n[0],n[1],n[2]].map(x=>x.toString(16).padStart(2,'0')).join(''));

    // Zeichnet die S/V-Fläche passend zum aktuellen Hue
    function drawSV(){
      const ctx=sv.getContext('2d'), w=sv.width, hgt=sv.height;
      const [r,g,b]=hsv2rgb(hue,1,1);
      ctx.fillStyle=`rgb(${r},${g},${b})`; ctx.fillRect(0,0,w,hgt);      // Grundfarbe (Hue)
      const grdW=ctx.createLinearGradient(0,0,w,0);                      // Weißverlauf (links)
      grdW.addColorStop(0,'#fff'); grdW.addColorStop(1,'transparent');   // -> Sättigung
      ctx.fillStyle=grdW; ctx.fillRect(0,0,w,hgt);
      const grdB=ctx.createLinearGradient(0,0,0,hgt);                    // Schwarzverlauf (unten)
      grdB.addColorStop(0,'transparent'); grdB.addColorStop(1,'#000');   // -> Helligkeit
      ctx.fillStyle=grdB; ctx.fillRect(0,0,w,hgt);
      // Cursor passend zu S/V platzieren
      svc.style.left = (sat * w - svc.offsetWidth/2)+'px';
      svc.style.top  = ((1-val) * hgt - svc.offsetHeight/2)+'px';
    }

    // Aus HSV setzen (und UI/Preview anpassen)
    function setFromHSV(hh,ss,vv){
      hue=hh; sat=Math.min(1,Math.max(0,ss)); val=Math.min(1,Math.max(0,vv));
      const [r,g,b]=hsv2rgb(hue,sat,val);
      preview.style.background=`rgb(${r},${g},${b})`;
      Rin.value=r; Gin.value=g; Bin.value=b;
      drawSV();
    }

    // Aus RGB setzen (berechnet HSV zurück)
    function setFromRGB(r,g,b){
      r=Math.min(255,Math.max(0,+r|0));
      g=Math.min(255,Math.max(0,+g|0));
      b=Math.min(255,Math.max(0,+b|0));
      const hsv=rgb2hsv(r,g,b); hue=hsv[0]; sat=hsv[1]; val=hsv[2];
      h.value=Math.round(hue);
      preview.style.background=`rgb(${r},${g},${b})`;
      Rin.value=r; Gin.value=g; Bin.value=b;
      drawSV();
    }

    // Öffnet den Farb-Dialog und initialisiert ihn mit der aktuellen Farbe
    function openPicker(key){
      currentKey=key;
      picker.querySelector('h4').textContent = `${labels[key] || 'Select'} – Select color`;
      const col = localStorage.getItem('color-'+key) || defaults[key];
      const r=parseInt(col.slice(1,3),16), g=parseInt(col.slice(3,5),16), b=parseInt(col.slice(5,7),16);
      setFromRGB(r,g,b);
      pickerOverlay.style.display='block'; picker.style.display='block';
      // Canvas an Dialogbreite anpassen
      const rect=picker.getBoundingClientRect();
      sv.width = Math.floor(rect.width-28);
      sv.height=180;
      drawSV();
    }

    // Schließt den Farb-Dialog
    function closePicker(){pickerOverlay.style.display='none'; picker.style.display='none'; currentKey=null;}
    pickerOverlay.addEventListener('click',closePicker);
    document.getElementById('cancelPick').addEventListener('click',closePicker);

    // Interaktionen im Dialog
    h.addEventListener('input',()=> setFromHSV(+h.value, sat, val));                 // Hue ändern
    Rin.addEventListener('input',()=> setFromRGB(Rin.value,Gin.value,Bin.value));   // direkte RGB-Eingabe
    Gin.addEventListener('input',()=> setFromRGB(Rin.value,Gin.value,Bin.value));
    Bin.addEventListener('input',()=> setFromRGB(Rin.value,Gin.value,Bin.value));

    // SV-Fläche mit Maus/Touch bedienen
    function handleSV(clientX,clientY){
      const r=sv.getBoundingClientRect();
      const x=Math.min(Math.max(clientX-r.left,0),r.width);
      const y=Math.min(Math.max(clientY-r.top,0),r.height);
      const s=x/r.width, v=1-y/r.height;
      setFromHSV(hue,s,v);
    }
    let svDrag=false;
    sv.addEventListener('mousedown',e=>{svDrag=true;handleSV(e.clientX,e.clientY)});
    document.addEventListener('mousemove',e=>{if(svDrag) handleSV(e.clientX,e.clientY)});
    document.addEventListener('mouseup',()=>svDrag=false);
    sv.addEventListener('touchstart',e=>{svDrag=true;handleSV(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
    sv.addEventListener('touchmove',e=>{if(svDrag){e.preventDefault();handleSV(e.touches[0].clientX,e.touches[0].clientY)}},{passive:false});
    sv.addEventListener('touchend',()=>svDrag=false);

    // „Apply“ übernimmt die Farbe im HEX-Format
    document.getElementById('applyPick').addEventListener('click',()=>{
      const hex = toHex([Rin.value|0, Gin.value|0, Bin.value|0]);
      applyColor(currentKey, hex);
      closePicker();
    });

    // Jeder Chip öffnet den Picker mit dem passenden Key
    Object.keys(mapping).forEach(k=>{
      document.getElementById(mapping[k]).addEventListener('click',()=>openPicker(k));
    });

    /* =========================
       Auto‑Reset (Speichern/Load)
       ========================= */

    const autoResetEnableEl = document.getElementById('autoResetEnable');
    const autoResetSecondsEl = document.getElementById('autoResetSeconds');

    // Standard: aktiviert, 10s – falls nichts gespeichert ist
    let autoResetEnabled = localStorage.getItem('autoResetEnabled') === 'false' ? false : true;
    let autoResetSeconds = localStorage.getItem('autoResetSeconds')
      ? parseInt(localStorage.getItem('autoResetSeconds'), 10)
      : 10;

    // Spiegelt den aktuellen Zustand in die UI
    function syncResetUI(){
      autoResetEnableEl.checked = autoResetEnabled;
      autoResetSecondsEl.value = autoResetSeconds;
      autoResetSecondsEl.disabled = !autoResetEnabled;
    }

    // Änderungen aus der UI übernehmen & speichern
    autoResetEnableEl.addEventListener('change',()=>{
      autoResetEnabled = autoResetEnableEl.checked;
      localStorage.setItem('autoResetEnabled', String(autoResetEnabled));
      autoResetSecondsEl.disabled = !autoResetEnabled;
      startInactivityTimer();
    });
    autoResetSecondsEl.addEventListener('input',()=>{
      const v = Math.max(1, Math.min(3600, parseInt(autoResetSecondsEl.value||'10',10)));
      autoResetSeconds = v;
      localStorage.setItem('autoResetSeconds', String(autoResetSeconds));
      startInactivityTimer();
    });

    // Erster Besuch: Defaults setzen; danach gespeicherte Werte verwenden
    window.addEventListener('load',()=>{
      if(!localStorage.getItem('visitedBefore')){
        localStorage.setItem('visitedBefore','true');
        // Farb-Overrides löschen, damit die Defaults sichtbar werden
        Object.keys(mapping).forEach(k=>localStorage.removeItem('color-'+k));
        // Und Auto‑Reset sicher auf 10s/aktiv setzen
        localStorage.setItem('autoResetEnabled','true');
        localStorage.setItem('autoResetSeconds','10');
        autoResetEnabled = true;
        autoResetSeconds = 10;
      }
      applySavedColors();
      syncResetUI();
    });
  </script>
</body>
</html>


